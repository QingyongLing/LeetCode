####给定两个字符串s1,s2，判断给出的第三个字符串s3是否由前面两个字符串组成，其中在第三个字符串中，第一和第二字符串的元素逻辑顺序保持不变
#####给的提示是动态规划
试了下回溯，发现超时，那么动态规划要怎么着手呢，怎么定义动态规划的状态呢？隐隐约约觉得和路径之类的有几分相似，比如说从某个点出发，然后看能否到达某个点，发散一下思维感觉似乎可以这么搞。具体方法：         
定义一个矩形的，从起始点（左上角）到右下角，判断能否到达，那么转移条件是什么呢，比如s3的当前字符和s2对应字符相同那就往右走一步，如果s3的对应字符与s1的对应字符相同，那就可以往下走一步，最终右下角如果可以到达，那么返回true。          
用正式一点的语言描述，应该是假设一个状态：        
d(i,j)==1表示s3的[0,i+j-1]部分含有[0,i-1]的s1和[0,j-1]的s2，那么：         
d(i,j)的状态有两种可能到达，第一种是从d(i-1,j)到达，第二种是从d(i,j-1)到达，那么到达的条件分别是：        
d(i-1,j)==1&&s1[i-1]==s3[i+j-1]   ---->    d(i,j)=1      
d(i,j-1)==1&&s1[j-1]==s3[i+j-1]   ---->    d(i,j)=1      
最后得到的d(s1.size(),s2.size())就是答案。      
用一个示意图可以表示为：       
s1=acd      
s2=efa      
s3=aefcda      

|   |   | a | c | d |
|---|---|---|---|---|
|   |   | 1 |   |   |
| e |   | 1 |   |   |
| f |   | 1 | 1 | 1 |
| a |   |   |   | 1 |
那么代码为：
```cpp
bool isInterleave(string s1, string s2, string s3) {
    if (s1.size() + s2.size() != s3.size())
        return false;
    vector<vector<int>> flag(s1.size() + 1, vector<int>(s2.size() + 1, 0));
    for (int i = 0; i < flag.size(); ++i) {
        for (int j = 0; j < flag[0].size(); ++j) {
            if (i == 0 && j == 0)
                flag[i][j] = 1;
            else {
                if (j > 0 && flag[i][j - 1] && s3[i + j - 1] == s2[j - 1])
                    flag[i][j] = 1;
                if (i > 0 && flag[i - 1][j] && s3[i + j - 1] == s1[i - 1])
                    flag[i][j] = 1;
            }
        }
    }
    return flag[s1.size()][s2.size()];
}
```